from collections import deque
from dataclasses import dataclass, asdict
import dataclasses
from abc import ABC, abstractmethod
import json
import logging
from mojograsp.simcore.action import Action, ActionDefault
from mojograsp.simcore.reward import Reward, RewardDefault
from mojograsp.simcore.state import State, StateDefault


@dataclass
class Timestep:
    """Dataclass for holding all of the data from a timestep"""
    episode: int = None
    timestep: int = None
    state: dict = None
    action: dict = None
    reward: dict = None
    next_state: dict = None


class ReplayBuffer(ABC):
    """ReplayBuffer Abstract Base Class"""
    @abstractmethod
    def __init__(self):
        pass

    @abstractmethod
    def add_timestep(self, episode_num: int, timestep_num: int):
        """
        Method required to add a timestep to the replay buffer, 
        must specify the episode number and the timestep number. These are both given by the :func:`~mojograsp.simcore.sim_manager.SimManager`.

        :param episode_num: corresponding episode number of the timestep.
        :param timestep_num: corresponding timestep number.
        :type episode_num: int
        :type timestep_num: int
        """
        pass

    @abstractmethod
    def save_buffer(self, filename: str):
        """
        Method to save the resulting buffer to an output file.

        :param filename: file path to save the result. 
        """
        pass


class ReplayBufferDefault:
    def __init__(self, buffer_size: int = 10000, no_delete=False, state: State = StateDefault,
                 action: Action = ActionDefault, reward: Reward = RewardDefault):
        '''
        Constructor takes in the necessary state, action, reward objects and sets the parameters of the 
        replay buffer. Currently only even sampling is supported by this replay buffer (no weighted transitions)
        but it could be added fairly easily. 

        :param buffer_size: Size of the deque before oldest entry is deleted.
        :param no_delete: Set if you do not wish old entries to be deleted. 
        :param state: State objecct.
        :param action: action objecct.
        :param reward: Reward objecct.
        :type buffer_size: int
        :type no_delete: bool
        :type state: :func:`~mojograsp.simcore.state.State` 
        :type action: :func:`~mojograsp.simcore.action.Action` 
        :type reward: :func:`~mojograsp.simcore.reward.Reward` 

        '''
        self.buffer_size = buffer_size
        self.prev_timestep = None
        self.state = state
        self.reward = reward
        self.action = action

        # deque data structure deletes oldest entry in array once buffer_size is exceeded
        if no_delete:
            # no deletion limit
            self.buffer = deque()
        else:
            self.buffer = deque(maxlen=buffer_size)

    def load_buffer_JSON(self, file_path: str):
        """
        This method should be called by the user to load the replay buffer after initialization
        with a Json file generated by :func:`~mojograsp.simcore.record_data.RecordDataJSON` with the save_all
        paramater = True. This will populate the buffer with every timestep from every episode recorded. 

        :param file_path: file path to json file.
        :type file_path: str
        """
        # clear buffer if not clear already
        self.buffer.clear()
        with open(file_path) as f:
            # load json file
            data = json.load(f)
            # for every entry in episode list, get the timestep list. For every timestep get the corresponding dictionary
            for i in data["episode_list"]:
                for j in i["timestep_list"]:
                    # create a new timestep with everything except for next state
                    tstep = Timestep(episode=int(i["number"]), timestep=int(
                        j["number"]), state=j["state"], action=j["action"], reward=j["reward"])
                    # call backfill to fill in the previous next state with current state
                    self.backfill(tstep)
                self.prev_timestep = None

    def load_buffer_BUFFER(self, file_path: str):
        """
        This method should be called by the user to load the replay buffer after initialization
        with a previously saved replay buffer json file generated by ReplayBufferDefault.
        This will populate the buffer with every timestep.

        :param file_path: file path to json file.
        :type file_path: str
        """

        # clear buffer if not clear
        self.buffer.clear()
        with open(file_path) as f:
            data = json.load(f)
            # read in every timestep and recreate the buffer
            for i in data:
                # dont need to backfill as next_state was saved from previous buffer.
                tstep = Timestep(episode=int(i["episode"]), timestep=int(
                    i["timestep"]), state=i["state"], action=i["action"], reward=i["reward"],
                    next_state=i["next_state"])
                self.buffer.append(tstep)
            self.prev_timestep = None

    def backfill(self, tstep: Timestep):
        """
        This method fills in the previous timestep nex_state (if it exists) with the current passed
        timestep's state. 

        :param tstep: Current Timestep dataclass object
        :type tstep: Timestep()
        """
        # check if there is a previous timestep and that it is not from last episode.
        if self.prev_timestep and self.prev_timestep != tstep.episode:
            self.prev_timestep == None
        # set next state of previous timestep to state of current timestep and add it to the buffer
        if self.prev_timestep:
            self.prev_timestep.next_state = tstep.state
            self.buffer.append(self.prev_timestep)
        # set new previous timestep to current one
        self.prev_timestep = tstep

    def add_timestep(self, episode_num: int, timestep_num: int):
        """
        Method adds a timestep using the state, action and reward get functions given the episode_num and
        timestep_num from the Simmanager. 

        :param episode_num: Episode number.
        :param timestep_num: Timestep number.
        :type episode_num: int
        :type timestep_num: int
        """
        tstep = Timestep(episode=episode_num, timestep=timestep_num, state=self.state.get_state,
                         action=self.action.get_action, reward=self.reward.get_reward)
        self.backfill(tstep)

    def save_buffer(self, file_path: str = None):
        """
        Method saves the current replay buffer to a json file at the location of the given file_path.

        :param file_path: desired destination and name of the json file.
        :type file_path: str
        """
        with open(file_path, 'w') as fout:
            temp_list = list(self.buffer)
            temp_list = [asdict(x) for x in temp_list]
            json.dump(temp_list, fout)
